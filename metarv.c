/* metarv.c generated by valac 0.10.0, the Vala compiler
 * generated from metarv.vala, do not modify */

/*using GLib;*/
/*
TODO:
1. log facility
2. rrd integration
3. formatted output
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <glib/gstdio.h>
#include <float.h>
#include <math.h>


#define TYPE_CONFIG (config_get_type ())
#define CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONFIG, Config))
#define CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONFIG, ConfigClass))
#define IS_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONFIG))
#define IS_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONFIG))
#define CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONFIG, ConfigClass))

typedef struct _Config Config;
typedef struct _ConfigClass ConfigClass;
typedef struct _ConfigPrivate ConfigPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define CONFIG_TYPE_CMD_OPT (config_cmd_opt_get_type ())
#define CONFIG_CMD_OPT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CONFIG_TYPE_CMD_OPT, ConfigCmdOpt))
#define CONFIG_CMD_OPT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CONFIG_TYPE_CMD_OPT, ConfigCmdOptClass))
#define CONFIG_IS_CMD_OPT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CONFIG_TYPE_CMD_OPT))
#define CONFIG_IS_CMD_OPT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CONFIG_TYPE_CMD_OPT))
#define CONFIG_CMD_OPT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CONFIG_TYPE_CMD_OPT, ConfigCmdOptClass))

typedef struct _ConfigCmdOpt ConfigCmdOpt;
typedef struct _ConfigCmdOptClass ConfigCmdOptClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
typedef struct _ConfigCmdOptPrivate ConfigCmdOptPrivate;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

#define TYPE_WEATHER_SITE (weather_site_get_type ())
#define WEATHER_SITE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WEATHER_SITE, WeatherSite))
#define WEATHER_SITE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WEATHER_SITE, WeatherSiteClass))
#define IS_WEATHER_SITE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WEATHER_SITE))
#define IS_WEATHER_SITE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WEATHER_SITE))
#define WEATHER_SITE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WEATHER_SITE, WeatherSiteClass))

typedef struct _WeatherSite WeatherSite;
typedef struct _WeatherSiteClass WeatherSiteClass;
typedef struct _WeatherSitePrivate WeatherSitePrivate;

#define TYPE_DECODED_DATA (decoded_data_get_type ())
#define DECODED_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DECODED_DATA, DecodedData))
#define DECODED_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DECODED_DATA, DecodedDataClass))
#define IS_DECODED_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DECODED_DATA))
#define IS_DECODED_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DECODED_DATA))
#define DECODED_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DECODED_DATA, DecodedDataClass))

typedef struct _DecodedData DecodedData;
typedef struct _DecodedDataClass DecodedDataClass;
typedef struct _DecodedDataPrivate DecodedDataPrivate;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))

#define DECODED_DATA_TYPE_FLAGS (decoded_data_flags_get_type ())
#define _g_time_zone_unref0(var) ((var == NULL) ? NULL : (var = (g_time_zone_unref (var), NULL)))

#define TYPE_FORMATTER (formatter_get_type ())
#define FORMATTER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FORMATTER, Formatter))
#define FORMATTER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FORMATTER, FormatterClass))
#define IS_FORMATTER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FORMATTER))
#define IS_FORMATTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FORMATTER))
#define FORMATTER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FORMATTER, FormatterClass))

typedef struct _Formatter Formatter;
typedef struct _FormatterClass FormatterClass;
typedef struct _FormatterPrivate FormatterPrivate;

#define TYPE_METAR (metar_get_type ())
#define METAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METAR, Metar))
#define METAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METAR, MetarClass))
#define IS_METAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METAR))
#define IS_METAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METAR))
#define METAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METAR, MetarClass))

typedef struct _Metar Metar;
typedef struct _MetarClass MetarClass;
typedef struct _MetarPrivate MetarPrivate;

struct _Config {
	GObject parent_instance;
	ConfigPrivate * priv;
	char* last_file;
};

struct _ConfigClass {
	GObjectClass parent_class;
};

struct _ConfigPrivate {
	char* config_path;
};

struct _ConfigCmdOpt {
	GObject parent_instance;
	ConfigCmdOptPrivate * priv;
};

struct _ConfigCmdOptClass {
	GObjectClass parent_class;
};

struct _WeatherSite {
	GObject parent_instance;
	WeatherSitePrivate * priv;
	char* raw_text;
};

struct _WeatherSiteClass {
	GObjectClass parent_class;
};

struct _WeatherSitePrivate {
	GInetAddress* server_inet;
	Config* config;
};

struct _DecodedData {
	GObject parent_instance;
	DecodedDataPrivate * priv;
	char* raw_code;
	char* short_name;
	char* full_name;
	double temperature;
	double dew_point;
	double wind_speed;
	double wind_direction;
	double wind_gust;
	char* wind_unit;
	double wind_variation[2];
	double visibility;
	double atmo_pressure;
	GDateTime* local;
	char** extras;
	gint extras_length1;
	gint _extras_size_;
};

struct _DecodedDataClass {
	GObjectClass parent_class;
};

typedef enum  {
	DECODED_DATA_FLAGS_NAME = 1,
	DECODED_DATA_FLAGS_TIME = 1 << 1,
	DECODED_DATA_FLAGS_WIND = 1 << 2,
	DECODED_DATA_FLAGS_WIND_VARY = 1 << 3,
	DECODED_DATA_FLAGS_VISIBILITY = 1 << 4,
	DECODED_DATA_FLAGS_ATMO_PRES = 1 << 5,
	DECODED_DATA_FLAGS_TEMPERATURE = 1 << 6,
	DECODED_DATA_FLAGS_NOSIG = 1 << 7
} DecodedDataFlags;

struct _Formatter {
	GObject parent_instance;
	FormatterPrivate * priv;
};

struct _FormatterClass {
	GObjectClass parent_class;
};

struct _FormatterPrivate {
	DecodedData* data;
	Config* config;
};

struct _Metar {
	GObject parent_instance;
	MetarPrivate * priv;
};

struct _MetarClass {
	GObjectClass parent_class;
};


extern char* config_site_name;
char* config_site_name = NULL;
extern char* config_server_name;
char* config_server_name = NULL;
extern char* config_uri_path_metar;
char* config_uri_path_metar = NULL;
extern char* config_uri_path_filename;
char* config_uri_path_filename = NULL;
extern char* config_format_output;
char* config_format_output = NULL;
extern char* config_output_type;
char* config_output_type = NULL;
extern gboolean config_imperial_units;
gboolean config_imperial_units = FALSE;
static gpointer config_cmd_opt_parent_class = NULL;
static gpointer config_parent_class = NULL;
static gpointer weather_site_parent_class = NULL;
static gpointer decoded_data_parent_class = NULL;
static gpointer formatter_parent_class = NULL;
static gpointer metar_parent_class = NULL;

GType config_get_type (void) G_GNUC_CONST;
#define CONFIG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CONFIG, ConfigPrivate))
enum  {
	CONFIG_DUMMY_PROPERTY
};
Config* config_new (char** args, int args_length1);
Config* config_construct (GType object_type, char** args, int args_length1);
static void config_write_config_file (Config* self);
static void config_parse_config_file (Config* self);
static ConfigCmdOpt* config_cmd_opt_new (char** args, int args_length1);
static ConfigCmdOpt* config_cmd_opt_construct (GType object_type, char** args, int args_length1);
static GType config_cmd_opt_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void config_print_format_detail (Config* self);
void metar_abnormal_exit (GError* e, const char* str);
enum  {
	CONFIG_CMD_OPT_DUMMY_PROPERTY
};
static void config_finalize (GObject* obj);
GType weather_site_get_type (void) G_GNUC_CONST;
#define WEATHER_SITE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_WEATHER_SITE, WeatherSitePrivate))
enum  {
	WEATHER_SITE_DUMMY_PROPERTY
};
WeatherSite* weather_site_new (Config* config);
WeatherSite* weather_site_construct (GType object_type, Config* config);
DecodedData* decoded_data_new (const char* raw);
DecodedData* decoded_data_construct (GType object_type, const char* raw);
GType decoded_data_get_type (void) G_GNUC_CONST;
static void weather_site_get_raw (WeatherSite* self);
static void weather_site_write_last (WeatherSite* self);
static void _g_list_free_g_object_unref (GList* self);
static void weather_site_finalize (GObject* obj);
enum  {
	DECODED_DATA_DUMMY_PROPERTY
};
static GType decoded_data_flags_get_type (void) G_GNUC_UNUSED;
static void _vala_array_add1 (char*** array, int* length, int* size, char* value);
static void decoded_data_finalize (GObject* obj);
GType formatter_get_type (void) G_GNUC_CONST;
#define FORMATTER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_FORMATTER, FormatterPrivate))
enum  {
	FORMATTER_DUMMY_PROPERTY
};
Formatter* formatter_new (Config* conf, DecodedData* data);
Formatter* formatter_construct (GType object_type, Config* conf, DecodedData* data);
void formatter_output (Formatter* self);
static void formatter_finalize (GObject* obj);
GType metar_get_type (void) G_GNUC_CONST;
enum  {
	METAR_DUMMY_PROPERTY
};
gint metar_main (char** args, int args_length1);
Metar* metar_new (void);
Metar* metar_construct (GType object_type);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);

static const GOptionEntry CONFIG_CMD_OPT_opts[5] = {{"site", 's', 0, G_OPTION_ARG_STRING, &config_site_name, "specify metar station.", "<name>"}, {"output", 'o', 0, G_OPTION_ARG_STRING, &config_output_type, "output type: [general|raw|format] (default: general).", "<type>"}, {"format", 'f', 0, G_OPTION_ARG_STRING, &config_format_output, "customized formatted string. use '--format help' for more detail.", "<string>"}, {"imperial", 'i', 0, G_OPTION_ARG_NONE, &config_imperial_units, "use imperial units (feet, fahrenheit, etc.), default is metric.", NULL}, {NULL}};
static GRegex* _tmp4_regex_0 = NULL;
static GRegex* _tmp7_regex_1 = NULL;
static GRegex* _tmp15_regex_2 = NULL;
static GRegex* _tmp21_regex_3 = NULL;
static GRegex* _tmp27_regex_4 = NULL;
static GRegex* _tmp31_regex_5 = NULL;
static GRegex* _tmp33_regex_6 = NULL;
static GRegex* _tmp44_regex_7 = NULL;
static GRegex* _tmp47_regex_8 = NULL;
static GRegex* _tmp50_regex_9 = NULL;


Config* config_construct (GType object_type, char** args, int args_length1) {
	Config * self;
	GFile* _tmp0_;
	gboolean _tmp1_;
	ConfigCmdOpt* _tmp2_;
	self = (Config*) g_object_new (object_type, NULL);
	if ((_tmp1_ = g_file_query_exists (_tmp0_ = g_file_new_for_path (self->priv->config_path), NULL) == FALSE, _g_object_unref0 (_tmp0_), _tmp1_)) {
		fprintf (stderr, "Creating configuration file: %s\n", self->priv->config_path);
		config_write_config_file (self);
	} else {
		config_parse_config_file (self);
	}
	_tmp2_ = config_cmd_opt_new (args, args_length1);
	_g_object_unref0 (_tmp2_);
	if (_vala_strcmp0 (config_format_output, "help") == 0) {
		config_print_format_detail (self);
	}
	return self;
}


Config* config_new (char** args, int args_length1) {
	return config_construct (TYPE_CONFIG, args, args_length1);
}


static void config_write_config_file (Config* self) {
	GKeyFile* c;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	c = g_key_file_new ();
	g_key_file_set_string (c, "service", "server_name", config_server_name);
	g_key_file_set_string (c, "service", "uri_path_metar", config_uri_path_metar);
	g_key_file_set_string (c, "service", "site_name", config_site_name);
	g_key_file_set_string (c, "service", "output_type", config_output_type);
	g_key_file_set_string (c, "service", "format_output", config_format_output);
	g_key_file_set_boolean (c, "service", "imperial_units", config_imperial_units);
	{
		char* _tmp0_;
		char* _tmp1_;
		g_file_set_contents (self->priv->config_path, _tmp1_ = g_strconcat ("# Automatically generated, only change if you know what you are doing." \
"\n" \
"# If something goes wrong, let the program regenerate one for you.\n", _tmp0_ = g_key_file_to_data (c, NULL, NULL), NULL), -1, &_inner_error_);
		_g_free0 (_tmp1_);
		_g_free0 (_tmp0_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			metar_abnormal_exit (e, "Failed to create a new configuration file.\n");
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_key_file_free0 (c);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_key_file_free0 (c);
}


static void config_parse_config_file (Config* self) {
	GKeyFile* c;
	char* _tmp12_;
	char* _tmp13_;
	char* _tmp14_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	c = g_key_file_new ();
	{
		char* _tmp0_;
		char* _tmp1_;
		char* _tmp2_;
		char* _tmp3_;
		char* _tmp4_;
		char* _tmp5_;
		char* _tmp6_;
		char* _tmp7_;
		char* _tmp8_;
		char* _tmp9_;
		char* _tmp10_;
		gboolean _tmp11_;
		g_key_file_load_from_file (c, self->priv->config_path, G_KEY_FILE_KEEP_COMMENTS, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		_tmp0_ = g_key_file_get_string (c, "service", "server_name", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		config_server_name = (_tmp1_ = _tmp0_, _g_free0 (config_server_name), _tmp1_);
		_tmp2_ = g_key_file_get_string (c, "service", "uri_path_metar", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		config_uri_path_metar = (_tmp3_ = _tmp2_, _g_free0 (config_uri_path_metar), _tmp3_);
		_tmp4_ = g_key_file_get_string (c, "service", "site_name", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		config_site_name = (_tmp6_ = g_utf8_strup (_tmp5_ = _tmp4_, -1), _g_free0 (config_site_name), _tmp6_);
		_g_free0 (_tmp5_);
		_tmp7_ = g_key_file_get_string (c, "service", "output_type", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		config_output_type = (_tmp8_ = _tmp7_, _g_free0 (config_output_type), _tmp8_);
		_tmp9_ = g_key_file_get_string (c, "service", "format_output", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		config_format_output = (_tmp10_ = _tmp9_, _g_free0 (config_format_output), _tmp10_);
		_tmp11_ = g_key_file_get_boolean (c, "service", "imperial_units", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		config_imperial_units = _tmp11_;
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			metar_abnormal_exit (e, "Configuration file parse error, try deleting it.\n");
			_g_error_free0 (e);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_key_file_free0 (c);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	config_uri_path_filename = (_tmp14_ = g_strconcat (_tmp13_ = g_strconcat (config_uri_path_metar, _tmp12_ = g_utf8_strup (config_site_name, -1), NULL), ".TXT", NULL), _g_free0 (config_uri_path_filename), _tmp14_);
	_g_free0 (_tmp13_);
	_g_free0 (_tmp12_);
	_g_key_file_free0 (c);
}


static void config_print_format_detail (Config* self) {
	g_return_if_fail (self != NULL);
	fprintf (stdout, "Available formatting options:\n\n");
	fprintf (stdout, "  %%s = short station name\n");
	fprintf (stdout, "  %%S = long station name \n");
	fprintf (stdout, "  %%l = local time\n");
	fprintf (stdout, "  %%t = temperature\n");
	fprintf (stdout, "  %%d = dew point\n");
	fprintf (stdout, "  %%w = wind speed\n");
	fprintf (stdout, "  %%D = wind direction\n");
	fprintf (stdout, "  %%g = wind gust speed\n");
	fprintf (stdout, "\n");
	exit (0);
}


static const char* string_to_string (const char* self) {
	const char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static ConfigCmdOpt* config_cmd_opt_construct (GType object_type, char** args, int args_length1) {
	ConfigCmdOpt * self;
	GError * _inner_error_ = NULL;
	self = (ConfigCmdOpt*) g_object_new (object_type, NULL);
	{
		GOptionContext* k;
		k = g_option_context_new ("- provides weather conditions decoded from METAR codes.");
		g_option_context_set_help_enabled (k, TRUE);
		g_option_context_add_main_entries (k, CONFIG_CMD_OPT_opts, NULL);
		g_option_context_parse (k, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_option_context_free0 (k);
			if (_inner_error_->domain == G_OPTION_ERROR) {
				goto __catch2_g_option_error;
			}
			_g_option_context_free0 (k);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_option_context_free0 (k);
	}
	goto __finally2;
	__catch2_g_option_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			char* _tmp0_;
			metar_abnormal_exit (e, _tmp0_ = g_strconcat ("Run '", string_to_string (args[0]), " --help' to see a full list of available command line options.\n", NULL));
			_g_free0 (_tmp0_);
			_g_error_free0 (e);
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


static ConfigCmdOpt* config_cmd_opt_new (char** args, int args_length1) {
	return config_cmd_opt_construct (CONFIG_TYPE_CMD_OPT, args, args_length1);
}


static void config_cmd_opt_class_init (ConfigCmdOptClass * klass) {
	config_cmd_opt_parent_class = g_type_class_peek_parent (klass);
}


static void config_cmd_opt_instance_init (ConfigCmdOpt * self) {
}


static GType config_cmd_opt_get_type (void) {
	static volatile gsize config_cmd_opt_type_id__volatile = 0;
	if (g_once_init_enter (&config_cmd_opt_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConfigCmdOptClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) config_cmd_opt_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ConfigCmdOpt), 0, (GInstanceInitFunc) config_cmd_opt_instance_init, NULL };
		GType config_cmd_opt_type_id;
		config_cmd_opt_type_id = g_type_register_static (G_TYPE_OBJECT, "ConfigCmdOpt", &g_define_type_info, 0);
		g_once_init_leave (&config_cmd_opt_type_id__volatile, config_cmd_opt_type_id);
	}
	return config_cmd_opt_type_id__volatile;
}


static void config_class_init (ConfigClass * klass) {
	config_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ConfigPrivate));
	G_OBJECT_CLASS (klass)->finalize = config_finalize;
	config_site_name = g_strdup ("rckh");
	config_server_name = g_strdup ("weather.noaa.gov");
	config_uri_path_metar = g_strdup ("/pub/data/observations/metar/stations/");
	config_format_output = g_strdup ("");
	config_output_type = g_strdup ("general");
}


static void config_instance_init (Config * self) {
	self->priv = CONFIG_GET_PRIVATE (self);
	self->priv->config_path = g_strdup ("./metarvrc");
	self->last_file = g_strdup ("/tmp/metarv.last");
}


static void config_finalize (GObject* obj) {
	Config * self;
	self = CONFIG (obj);
	_g_free0 (self->priv->config_path);
	_g_free0 (self->last_file);
	G_OBJECT_CLASS (config_parent_class)->finalize (obj);
}


GType config_get_type (void) {
	static volatile gsize config_type_id__volatile = 0;
	if (g_once_init_enter (&config_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ConfigClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Config), 0, (GInstanceInitFunc) config_instance_init, NULL };
		GType config_type_id;
		config_type_id = g_type_register_static (G_TYPE_OBJECT, "Config", &g_define_type_info, 0);
		g_once_init_leave (&config_type_id__volatile, config_type_id);
	}
	return config_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


static char* string_strip (const char* self) {
	char* result = NULL;
	char* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_result_ = g_strdup (self);
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static void _g_list_free_g_object_unref (GList* self) {
	g_list_foreach (self, (GFunc) g_object_unref, NULL);
	g_list_free (self);
}


WeatherSite* weather_site_construct (GType object_type, Config* config) {
	WeatherSite * self;
	Config* _tmp0_;
	GResolver* resolver;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (config != NULL, NULL);
	self = (WeatherSite*) g_object_new (object_type, NULL);
	self->priv->config = (_tmp0_ = _g_object_ref0 (config), _g_object_unref0 (self->priv->config), _tmp0_);
	resolver = _g_object_ref0 (g_resolver_get_default ());
	{
		gboolean fetch_remote;
		GFile* _tmp1_;
		gboolean _tmp2_;
		fetch_remote = FALSE;
		if ((_tmp2_ = g_file_query_exists (_tmp1_ = g_file_new_for_path (config->last_file), NULL) == TRUE, _g_object_unref0 (_tmp1_), _tmp2_)) {
			char* temp;
			char* _tmp3_ = NULL;
			char* _tmp4_;
			temp = NULL;
			g_file_get_contents (config->last_file, &_tmp3_, NULL, &_inner_error_);
			temp = (_tmp4_ = _tmp3_, _g_free0 (temp), _tmp4_);
			if (_inner_error_ != NULL) {
				_g_free0 (temp);
				goto __catch3_g_error;
			}
			if (string_get_length (temp) != 0) {
				char* _tmp5_;
				DecodedData* f;
				GDateTime* d;
				GTimeSpan diff;
				temp = (_tmp5_ = string_strip (temp), _g_free0 (temp), _tmp5_);
				f = decoded_data_new (temp);
				d = g_date_time_new_now_local ();
				diff = g_date_time_difference (d, f->local);
				if (diff < 2400000000LL) {
					char* _tmp6_;
					self->raw_text = (_tmp6_ = g_strdup (temp), _g_free0 (self->raw_text), _tmp6_);
				} else {
					fetch_remote = TRUE;
				}
				_g_date_time_unref0 (d);
				_g_object_unref0 (f);
			} else {
				fetch_remote = TRUE;
			}
			_g_free0 (temp);
		} else {
			fetch_remote = TRUE;
		}
		if (fetch_remote == TRUE) {
			GList* addr_ls;
			GInetAddress* _tmp7_;
			addr_ls = g_resolver_lookup_by_name (resolver, config_server_name, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch3_g_error;
			}
			self->priv->server_inet = (_tmp7_ = _g_object_ref0 ((GInetAddress*) g_list_nth_data (addr_ls, (guint) 0)), _g_object_unref0 (self->priv->server_inet), _tmp7_);
			weather_site_get_raw (self);
			weather_site_write_last (self);
			__g_list_free_g_object_unref0 (addr_ls);
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			metar_abnormal_exit (e, "Network failure.\n");
			_g_error_free0 (e);
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (resolver);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_g_object_unref0 (resolver);
	return self;
}


WeatherSite* weather_site_new (Config* config) {
	return weather_site_construct (TYPE_WEATHER_SITE, config);
}


static char* string_slice (const char* self, glong start, glong end) {
	char* result = NULL;
	glong string_length;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const char* start_string;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp0_ = start <= string_length;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_val_if_fail (_tmp0_, NULL);
	if (end >= 0) {
		_tmp1_ = end <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	start_string = g_utf8_offset_to_pointer (self, start);
	result = g_strndup (start_string, ((gchar*) g_utf8_offset_to_pointer (start_string, end - start)) - ((gchar*) start_string));
	return result;
}


static void weather_site_get_raw (WeatherSite* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GSocketClient* client;
		GInetSocketAddress* _tmp0_;
		GSocketConnection* _tmp1_;
		GSocketConnection* conn;
		char* _tmp2_;
		char* _tmp3_;
		char* _tmp4_;
		char* _tmp5_;
		char* mesg;
		GDataInputStream* input;
		char* _tmp6_;
		char* _tmp7_;
		char* _tmp8_;
		gboolean _tmp9_;
		client = g_socket_client_new ();
		conn = (_tmp1_ = _g_object_ref0 (g_socket_client_connect (client, (GSocketConnectable*) (_tmp0_ = (GInetSocketAddress*) g_inet_socket_address_new (self->priv->server_inet, (guint16) 80)), NULL, &_inner_error_)), _g_object_unref0 (_tmp0_), _tmp1_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (client);
			goto __catch4_g_error;
		}
		mesg = (_tmp5_ = g_strconcat (_tmp4_ = g_strconcat (_tmp3_ = g_strconcat (_tmp2_ = g_strconcat ("GET ", config_uri_path_filename, NULL), " HTTP/1.1\r\nHost: ", NULL), config_server_name, NULL), "\r\n\r\n", NULL), _g_free0 (_tmp4_), _g_free0 (_tmp3_), _g_free0 (_tmp2_), _tmp5_);
		g_output_stream_write (g_io_stream_get_output_stream ((GIOStream*) conn), mesg, strlen (mesg), NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_free0 (mesg);
			_g_object_unref0 (conn);
			_g_object_unref0 (client);
			goto __catch4_g_error;
		}
		input = g_data_input_stream_new (g_io_stream_get_input_stream ((GIOStream*) conn));
		_tmp6_ = g_data_input_stream_read_line (input, NULL, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (input);
			_g_free0 (mesg);
			_g_object_unref0 (conn);
			_g_object_unref0 (client);
			goto __catch4_g_error;
		}
		if ((_tmp9_ = _vala_strcmp0 (_tmp8_ = string_strip (_tmp7_ = _tmp6_), "HTTP/1.1 200 OK") == 0, _g_free0 (_tmp8_), _g_free0 (_tmp7_), _tmp9_)) {
			char* _tmp14_;
			char* _tmp15_;
			{
				gboolean _tmp10_;
				_tmp10_ = TRUE;
				while (TRUE) {
					char* _tmp11_;
					char* _tmp12_;
					char* _tmp13_;
					if (!_tmp10_) {
						if (!(_vala_strcmp0 (mesg, "") != 0)) {
							break;
						}
					}
					_tmp10_ = FALSE;
					_tmp11_ = g_data_input_stream_read_line (input, NULL, NULL, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (input);
						_g_free0 (mesg);
						_g_object_unref0 (conn);
						_g_object_unref0 (client);
						goto __catch4_g_error;
					}
					mesg = (_tmp13_ = string_strip (_tmp12_ = _tmp11_), _g_free0 (mesg), _tmp13_);
					_g_free0 (_tmp12_);
				}
			}
			_tmp14_ = g_data_input_stream_read_line (input, NULL, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (input);
				_g_free0 (mesg);
				_g_object_unref0 (conn);
				_g_object_unref0 (client);
				goto __catch4_g_error;
			}
			mesg = (_tmp15_ = _tmp14_, _g_free0 (mesg), _tmp15_);
			{
				gboolean _tmp16_;
				_tmp16_ = TRUE;
				while (TRUE) {
					char* _tmp17_;
					char* _tmp18_;
					gboolean _tmp19_;
					char* _tmp21_;
					char* _tmp22_;
					if (!_tmp16_) {
						if (!(mesg != NULL)) {
							break;
						}
					}
					_tmp16_ = FALSE;
					if ((_tmp19_ = _vala_strcmp0 (_tmp17_ = string_slice (mesg, (glong) 0, (glong) 4), _tmp18_ = g_utf8_strup (config_site_name, -1)) == 0, _g_free0 (_tmp18_), _g_free0 (_tmp17_), _tmp19_)) {
						char* _tmp20_;
						self->raw_text = (_tmp20_ = string_strip (mesg), _g_free0 (self->raw_text), _tmp20_);
					}
					_tmp21_ = g_data_input_stream_read_line (input, NULL, NULL, &_inner_error_);
					if (_inner_error_ != NULL) {
						_g_object_unref0 (input);
						_g_free0 (mesg);
						_g_object_unref0 (conn);
						_g_object_unref0 (client);
						goto __catch4_g_error;
					}
					mesg = (_tmp22_ = _tmp21_, _g_free0 (mesg), _tmp22_);
				}
			}
		}
		_g_object_unref0 (input);
		_g_free0 (mesg);
		_g_object_unref0 (conn);
		_g_object_unref0 (client);
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			metar_abnormal_exit (e, "");
			_g_error_free0 (e);
		}
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void weather_site_write_last (WeatherSite* self) {
	GFile* f;
	GFileOutputStream* stream;
	GDataOutputStream* s;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	f = g_file_new_for_path (self->priv->config->last_file);
	stream = g_file_replace (f, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (f);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	s = g_data_output_stream_new ((GOutputStream*) stream);
	g_data_output_stream_put_string (s, self->raw_text, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (s);
		_g_object_unref0 (stream);
		_g_object_unref0 (f);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (s);
	_g_object_unref0 (stream);
	_g_object_unref0 (f);
}


static void weather_site_class_init (WeatherSiteClass * klass) {
	weather_site_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (WeatherSitePrivate));
	G_OBJECT_CLASS (klass)->finalize = weather_site_finalize;
}


static void weather_site_instance_init (WeatherSite * self) {
	self->priv = WEATHER_SITE_GET_PRIVATE (self);
	self->raw_text = g_strdup ("");
}


static void weather_site_finalize (GObject* obj) {
	WeatherSite * self;
	self = WEATHER_SITE (obj);
	_g_object_unref0 (self->priv->server_inet);
	_g_object_unref0 (self->priv->config);
	_g_free0 (self->raw_text);
	G_OBJECT_CLASS (weather_site_parent_class)->finalize (obj);
}


GType weather_site_get_type (void) {
	static volatile gsize weather_site_type_id__volatile = 0;
	if (g_once_init_enter (&weather_site_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (WeatherSiteClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) weather_site_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (WeatherSite), 0, (GInstanceInitFunc) weather_site_instance_init, NULL };
		GType weather_site_type_id;
		weather_site_type_id = g_type_register_static (G_TYPE_OBJECT, "WeatherSite", &g_define_type_info, 0);
		g_once_init_leave (&weather_site_type_id__volatile, weather_site_type_id);
	}
	return weather_site_type_id__volatile;
}


static GType decoded_data_flags_get_type (void) {
	static volatile gsize decoded_data_flags_type_id__volatile = 0;
	if (g_once_init_enter (&decoded_data_flags_type_id__volatile)) {
		static const GEnumValue values[] = {{DECODED_DATA_FLAGS_NAME, "DECODED_DATA_FLAGS_NAME", "name"}, {DECODED_DATA_FLAGS_TIME, "DECODED_DATA_FLAGS_TIME", "time"}, {DECODED_DATA_FLAGS_WIND, "DECODED_DATA_FLAGS_WIND", "wind"}, {DECODED_DATA_FLAGS_WIND_VARY, "DECODED_DATA_FLAGS_WIND_VARY", "wind-vary"}, {DECODED_DATA_FLAGS_VISIBILITY, "DECODED_DATA_FLAGS_VISIBILITY", "visibility"}, {DECODED_DATA_FLAGS_ATMO_PRES, "DECODED_DATA_FLAGS_ATMO_PRES", "atmo-pres"}, {DECODED_DATA_FLAGS_TEMPERATURE, "DECODED_DATA_FLAGS_TEMPERATURE", "temperature"}, {DECODED_DATA_FLAGS_NOSIG, "DECODED_DATA_FLAGS_NOSIG", "nosig"}, {0, NULL, NULL}};
		GType decoded_data_flags_type_id;
		decoded_data_flags_type_id = g_enum_register_static ("DecodedDataFlags", values);
		g_once_init_leave (&decoded_data_flags_type_id__volatile, decoded_data_flags_type_id);
	}
	return decoded_data_flags_type_id__volatile;
}


static inline GRegex* _thread_safe_regex_init (GRegex** re, const gchar * pattern, GRegexMatchFlags match_options) {
	if (g_once_init_enter ((volatile gsize*) re)) {
		GRegex* val = g_regex_new (pattern, match_options, 0, NULL);
		g_once_init_leave ((volatile gsize*) re, (gsize) val);
	}
	return *re;
}


static char* string_substring (const char* self, glong offset, glong len) {
	char* result = NULL;
	glong string_length;
	const char* start;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	start = g_utf8_offset_to_pointer (self, offset);
	result = g_strndup (start, ((gchar*) g_utf8_offset_to_pointer (start, len)) - ((gchar*) start));
	return result;
}


static char* g_unichar_to_string (gunichar self) {
	char* result = NULL;
	char* str;
	str = (char*) g_new0 (gchar, 7);
	g_unichar_to_utf8 (self, str);
	result = str;
	return result;
}


static char* double_to_string (double self) {
	char* result = NULL;
	gchar* _tmp0_;
	gint _tmp0__length1;
	char* _tmp1_;
	result = (_tmp1_ = g_strdup (g_ascii_dtostr ((_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE), _tmp0__length1 = G_ASCII_DTOSTR_BUF_SIZE, _tmp0_), G_ASCII_DTOSTR_BUF_SIZE, self)), _tmp0_ = (g_free (_tmp0_), NULL), _tmp1_);
	return result;
}


static void _vala_array_add1 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


DecodedData* decoded_data_construct (GType object_type, const char* raw) {
	DecodedData * self;
	char* _tmp0_;
	gint k_length1;
	gint _k_size_;
	char** _tmp2_;
	char** _tmp1_;
	char** k;
	DecodedDataFlags flags;
	g_return_val_if_fail (raw != NULL, NULL);
	self = (DecodedData*) g_object_new (object_type, NULL);
	self->raw_code = (_tmp0_ = g_strdup (raw), _g_free0 (self->raw_code), _tmp0_);
	k = (_tmp2_ = _tmp1_ = g_strsplit (raw, " ", 0), k_length1 = _vala_array_length (_tmp1_), _k_size_ = k_length1, _tmp2_);
	flags = 0x0;
	{
		char** val_collection;
		int val_collection_length1;
		int val_it;
		val_collection = k;
		val_collection_length1 = k_length1;
		for (val_it = 0; val_it < k_length1; val_it = val_it + 1) {
			char* val;
			val = g_strdup (val_collection[val_it]);
			{
				gboolean _tmp3_ = FALSE;
				gboolean _tmp6_ = FALSE;
				gboolean _tmp14_ = FALSE;
				gboolean _tmp20_ = FALSE;
				gboolean _tmp26_ = FALSE;
				gboolean _tmp30_ = FALSE;
				gboolean _tmp32_ = FALSE;
				gboolean _tmp43_ = FALSE;
				gboolean _tmp46_ = FALSE;
				gboolean _tmp49_ = FALSE;
				if (_vala_strcmp0 (val, "METAR") == 0) {
					_g_free0 (val);
					continue;
				}
				if ((flags & DECODED_DATA_FLAGS_NAME) == 0) {
					_tmp3_ = g_regex_match (_thread_safe_regex_init (&_tmp4_regex_0, "^[A-Z]{4}$", 0), val, 0, NULL);
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					char* _tmp5_;
					self->short_name = (_tmp5_ = g_strdup (val), _g_free0 (self->short_name), _tmp5_);
					flags = flags | DECODED_DATA_FLAGS_NAME;
				}
				if ((flags & DECODED_DATA_FLAGS_TIME) == 0) {
					_tmp6_ = g_regex_match (_thread_safe_regex_init (&_tmp7_regex_1, "^[0-9]+Z$", 0), val, 0, NULL);
				} else {
					_tmp6_ = FALSE;
				}
				if (_tmp6_) {
					GDateTime* utc;
					GDateTime* now;
					char* _tmp8_;
					char* _tmp9_;
					char* _tmp10_;
					GDateTime* _tmp11_;
					GTimeZone* _tmp12_;
					GDateTime* _tmp13_;
					utc = NULL;
					now = g_date_time_new_now_utc ();
					utc = (_tmp11_ = g_date_time_new_utc (g_date_time_get_year (now), g_date_time_get_month (now), atoi (_tmp8_ = string_slice (val, (glong) 0, (glong) 2)), atoi (_tmp9_ = string_slice (val, (glong) 2, (glong) 4)), atoi (_tmp10_ = string_slice (val, (glong) 4, (glong) 6)), (double) 0), _g_date_time_unref0 (utc), _tmp11_);
					_g_free0 (_tmp10_);
					_g_free0 (_tmp9_);
					_g_free0 (_tmp8_);
					self->local = (_tmp13_ = g_date_time_to_timezone (utc, _tmp12_ = g_time_zone_new_local ()), _g_date_time_unref0 (self->local), _tmp13_);
					_g_time_zone_unref0 (_tmp12_);
					flags = flags | DECODED_DATA_FLAGS_TIME;
					_g_date_time_unref0 (now);
					_g_date_time_unref0 (utc);
				}
				if ((flags & DECODED_DATA_FLAGS_WIND) == 0) {
					_tmp14_ = g_regex_match (_thread_safe_regex_init (&_tmp15_regex_2, "^[0-9G]+(MPS|KT)$", 0), val, 0, NULL);
				} else {
					_tmp14_ = FALSE;
				}
				if (_tmp14_) {
					char* _tmp16_;
					char* _tmp17_;
					gint i;
					char* _tmp19_;
					self->wind_direction = (double) atoi (_tmp16_ = string_slice (val, (glong) 0, (glong) 3));
					_g_free0 (_tmp16_);
					self->wind_speed = (double) atoi (_tmp17_ = string_slice (val, (glong) 3, (glong) 5));
					_g_free0 (_tmp17_);
					i = 5;
					if (g_utf8_get_char (g_utf8_offset_to_pointer (val, 5)) == 'G') {
						char* _tmp18_;
						self->wind_gust = g_ascii_strtod (_tmp18_ = string_slice (val, (glong) 6, (glong) 8), NULL);
						_g_free0 (_tmp18_);
						i = 8;
					} else {
						self->wind_gust = (double) 0;
					}
					self->wind_unit = (_tmp19_ = string_substring (val, (glong) i, -1), _g_free0 (self->wind_unit), _tmp19_);
					if (_vala_strcmp0 (self->wind_unit, "MPS") == 0) {
						self->wind_gust = self->wind_gust * 1.9438445;
						self->wind_speed = self->wind_speed * 1.9438445;
					}
					flags = flags | DECODED_DATA_FLAGS_WIND;
				}
				if ((flags & DECODED_DATA_FLAGS_TEMPERATURE) == 0) {
					_tmp20_ = g_regex_match (_thread_safe_regex_init (&_tmp21_regex_3, "^M?[0-9]+\\/M?[0-9]+$", 0), val, 0, NULL);
				} else {
					_tmp20_ = FALSE;
				}
				if (_tmp20_) {
					gint temp_length1;
					gint _temp_size_;
					char** _tmp23_;
					char** _tmp22_;
					char** temp;
					char* _tmp24_;
					char* _tmp25_;
					temp = (_tmp23_ = _tmp22_ = g_strsplit (val, "/", 0), temp_length1 = _vala_array_length (_tmp22_), _temp_size_ = temp_length1, _tmp23_);
					self->temperature = (double) atoi (_tmp24_ = string_substring (temp[0], (glong) (-2), -1));
					_g_free0 (_tmp24_);
					self->dew_point = (double) atoi (_tmp25_ = string_substring (temp[1], (glong) (-2), -1));
					_g_free0 (_tmp25_);
					if (g_utf8_get_char (g_utf8_offset_to_pointer (temp[0], 0)) == 'M') {
						self->temperature = self->temperature * ((double) (-1));
					}
					if (g_utf8_get_char (g_utf8_offset_to_pointer (temp[1], 0)) == 'M') {
						self->dew_point = self->dew_point * ((double) (-1));
					}
					flags = flags | DECODED_DATA_FLAGS_TEMPERATURE;
					temp = (_vala_array_free (temp, temp_length1, (GDestroyNotify) g_free), NULL);
				}
				if ((flags & DECODED_DATA_FLAGS_WIND_VARY) == 0) {
					_tmp26_ = g_regex_match (_thread_safe_regex_init (&_tmp27_regex_4, "^[0-9]{3}V[0-9]{3}$", 0), val, 0, NULL);
				} else {
					_tmp26_ = FALSE;
				}
				if (_tmp26_) {
					gint temp_length1;
					gint _temp_size_;
					char** _tmp29_;
					char** _tmp28_;
					char** temp;
					temp = (_tmp29_ = _tmp28_ = g_strsplit (val, "V", 0), temp_length1 = _vala_array_length (_tmp28_), _temp_size_ = temp_length1, _tmp29_);
					self->wind_variation[0] = g_ascii_strtod (temp[0], NULL);
					self->wind_variation[1] = g_ascii_strtod (temp[1], NULL);
					flags = flags | DECODED_DATA_FLAGS_WIND_VARY;
					temp = (_vala_array_free (temp, temp_length1, (GDestroyNotify) g_free), NULL);
				}
				if ((flags & DECODED_DATA_FLAGS_VISIBILITY) == 0) {
					_tmp30_ = g_regex_match (_thread_safe_regex_init (&_tmp31_regex_5, "^[0-9]{4}$", 0), val, 0, NULL);
				} else {
					_tmp30_ = FALSE;
				}
				if (_tmp30_) {
					self->visibility = g_ascii_strtod (val, NULL);
					flags = flags | DECODED_DATA_FLAGS_VISIBILITY;
				}
				if ((flags & DECODED_DATA_FLAGS_VISIBILITY) == 0) {
					_tmp32_ = g_regex_match (_thread_safe_regex_init (&_tmp33_regex_6, "^(M?[0-9]\\/)?[0-9]+SM$", 0), val, 0, NULL);
				} else {
					_tmp32_ = FALSE;
				}
				if (_tmp32_) {
					char* _tmp34_;
					gboolean _tmp35_;
					char* _tmp41_;
					char* _tmp42_;
					if ((_tmp35_ = _vala_strcmp0 (_tmp34_ = string_slice (val, (glong) 0, (glong) 4), "M1/4") == 0, _g_free0 (_tmp34_), _tmp35_)) {
						self->visibility = (double) (-400);
					} else {
						double f = 0.0;
						if (g_utf8_get_char (g_utf8_offset_to_pointer (val, 1)) == '/') {
							char* _tmp36_;
							double _tmp37_;
							double a;
							char* _tmp38_;
							double _tmp39_;
							double b;
							a = (_tmp37_ = (double) atoi (_tmp36_ = g_unichar_to_string (g_utf8_get_char (g_utf8_offset_to_pointer (val, 0)))), _g_free0 (_tmp36_), _tmp37_);
							b = (_tmp39_ = (double) atoi (_tmp38_ = g_unichar_to_string (g_utf8_get_char (g_utf8_offset_to_pointer (val, 2)))), _g_free0 (_tmp38_), _tmp39_);
							f = a / b;
						} else {
							char* _tmp40_;
							f = g_ascii_strtod (_tmp40_ = string_slice (val, (glong) 0, (glong) (-2)), NULL);
							_g_free0 (_tmp40_);
						}
						self->visibility = f * 1609.344;
					}
					flags = flags | DECODED_DATA_FLAGS_VISIBILITY;
					g_print ("%s", _tmp42_ = g_strconcat (_tmp41_ = double_to_string (self->visibility), "\n", NULL));
					_g_free0 (_tmp42_);
					_g_free0 (_tmp41_);
				}
				if ((flags & DECODED_DATA_FLAGS_ATMO_PRES) == 0) {
					_tmp43_ = g_regex_match (_thread_safe_regex_init (&_tmp44_regex_7, "^Q[0-9]{4}$", 0), val, 0, NULL);
				} else {
					_tmp43_ = FALSE;
				}
				if (_tmp43_) {
					char* _tmp45_;
					self->atmo_pressure = g_ascii_strtod (_tmp45_ = string_substring (val, (glong) 1, -1), NULL);
					_g_free0 (_tmp45_);
					flags = flags | DECODED_DATA_FLAGS_ATMO_PRES;
				}
				if ((flags & DECODED_DATA_FLAGS_ATMO_PRES) == 0) {
					_tmp46_ = g_regex_match (_thread_safe_regex_init (&_tmp47_regex_8, "^A[0-9]{4}$", 0), val, 0, NULL);
				} else {
					_tmp46_ = FALSE;
				}
				if (_tmp46_) {
					char* _tmp48_;
					self->atmo_pressure = g_ascii_strtod (_tmp48_ = string_substring (val, (glong) 1, -1), NULL) * 33.863886;
					_g_free0 (_tmp48_);
					flags = flags | DECODED_DATA_FLAGS_ATMO_PRES;
				}
				if ((flags & DECODED_DATA_FLAGS_NOSIG) == 0) {
					_tmp49_ = g_regex_match (_thread_safe_regex_init (&_tmp50_regex_9, "^NOSIG$", 0), val, 0, NULL);
				} else {
					_tmp49_ = FALSE;
				}
				if (_tmp49_) {
					_vala_array_add1 (&self->extras, &self->extras_length1, &self->_extras_size_, g_strdup ("No significant weather change ahead."));
					flags = flags | DECODED_DATA_FLAGS_NOSIG;
				}
				_g_free0 (val);
			}
		}
	}
	k = (_vala_array_free (k, k_length1, (GDestroyNotify) g_free), NULL);
	return self;
}


DecodedData* decoded_data_new (const char* raw) {
	return decoded_data_construct (TYPE_DECODED_DATA, raw);
}


static void decoded_data_class_init (DecodedDataClass * klass) {
	decoded_data_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = decoded_data_finalize;
}


static void decoded_data_instance_init (DecodedData * self) {
	char** _tmp0_ = NULL;
	self->extras = (_tmp0_ = g_new0 (char*, 0 + 1), _tmp0_);
	self->extras_length1 = 0;
	self->_extras_size_ = self->extras_length1;
}


static void decoded_data_finalize (GObject* obj) {
	DecodedData * self;
	self = DECODED_DATA (obj);
	_g_free0 (self->raw_code);
	_g_free0 (self->short_name);
	_g_free0 (self->full_name);
	_g_free0 (self->wind_unit);
	_g_date_time_unref0 (self->local);
	self->extras = (_vala_array_free (self->extras, self->extras_length1, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (decoded_data_parent_class)->finalize (obj);
}


GType decoded_data_get_type (void) {
	static volatile gsize decoded_data_type_id__volatile = 0;
	if (g_once_init_enter (&decoded_data_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DecodedDataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) decoded_data_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DecodedData), 0, (GInstanceInitFunc) decoded_data_instance_init, NULL };
		GType decoded_data_type_id;
		decoded_data_type_id = g_type_register_static (G_TYPE_OBJECT, "DecodedData", &g_define_type_info, 0);
		g_once_init_leave (&decoded_data_type_id__volatile, decoded_data_type_id);
	}
	return decoded_data_type_id__volatile;
}


Formatter* formatter_construct (GType object_type, Config* conf, DecodedData* data) {
	Formatter * self;
	DecodedData* _tmp0_;
	Config* _tmp1_;
	g_return_val_if_fail (conf != NULL, NULL);
	g_return_val_if_fail (data != NULL, NULL);
	self = (Formatter*) g_object_new (object_type, NULL);
	self->priv->data = (_tmp0_ = _g_object_ref0 (data), _g_object_unref0 (self->priv->data), _tmp0_);
	self->priv->config = (_tmp1_ = _g_object_ref0 (conf), _g_object_unref0 (self->priv->config), _tmp1_);
	return self;
}


Formatter* formatter_new (Config* conf, DecodedData* data) {
	return formatter_construct (TYPE_FORMATTER, conf, data);
}


static char* g_date_time_to_string (GDateTime* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = g_date_time_format (self, "%FT%H:%M:%S%z");
	return result;
}


void formatter_output (Formatter* self) {
	const char* _tmp18_;
	GQuark _tmp19_;
	static GQuark _tmp19__label0 = 0;
	static GQuark _tmp19__label1 = 0;
	static GQuark _tmp19__label2 = 0;
	g_return_if_fail (self != NULL);
	_tmp18_ = config_output_type;
	_tmp19_ = (NULL == _tmp18_) ? 0 : g_quark_from_string (_tmp18_);
	if (_tmp19_ == ((0 != _tmp19__label0) ? _tmp19__label0 : (_tmp19__label0 = g_quark_from_static_string ("general"))))
	switch (0) {
		default:
		{
			char* _tmp0_;
			char* _tmp1_;
			char* _tmp2_;
			char* _tmp3_;
			char* _tmp4_;
			char* _tmp5_;
			char* _tmp6_;
			char* _tmp7_;
			char* _tmp8_;
			char* _tmp9_;
			gboolean _tmp10_ = FALSE;
			g_print ("%s", _tmp1_ = g_strconcat ("Local time  : ", string_to_string (_tmp0_ = g_date_time_to_string (self->priv->data->local)), "\n", NULL));
			_g_free0 (_tmp1_);
			_g_free0 (_tmp0_);
			g_print ("%s", _tmp3_ = g_strconcat ("Temperature : ", _tmp2_ = double_to_string (self->priv->data->temperature), " C\n", NULL));
			_g_free0 (_tmp3_);
			_g_free0 (_tmp2_);
			g_print ("%s", _tmp5_ = g_strconcat ("Dew point   : ", _tmp4_ = double_to_string (self->priv->data->dew_point), " C\n", NULL));
			_g_free0 (_tmp5_);
			_g_free0 (_tmp4_);
			g_print ("%s", _tmp9_ = g_strconcat ("Wind        : ", _tmp6_ = double_to_string (self->priv->data->wind_direction), " at ", _tmp7_ = double_to_string (self->priv->data->wind_speed), " knot (", _tmp8_ = double_to_string (self->priv->data->wind_speed * 1.852), " KM/h)\n", NULL));
			_g_free0 (_tmp9_);
			_g_free0 (_tmp8_);
			_g_free0 (_tmp7_);
			_g_free0 (_tmp6_);
			if (self->priv->data->wind_variation[0] != 0) {
				_tmp10_ = self->priv->data->wind_variation[1] != 0;
			} else {
				_tmp10_ = FALSE;
			}
			if (_tmp10_) {
				char* _tmp11_;
				char* _tmp12_;
				char* _tmp13_;
				g_print ("%s", _tmp13_ = g_strconcat ("              varying between ", _tmp11_ = double_to_string (self->priv->data->wind_variation[0]), " and ", _tmp12_ = double_to_string (self->priv->data->wind_variation[1]), "\n", NULL));
				_g_free0 (_tmp13_);
				_g_free0 (_tmp12_);
				_g_free0 (_tmp11_);
			}
			g_print ("%s", "Visibility  : ");
			if (self->priv->data->visibility > 1000) {
				g_print ("%.2f KM\n", self->priv->data->visibility / 1000);
			} else {
				char* _tmp14_;
				char* _tmp15_;
				g_print ("%s", _tmp15_ = g_strconcat (_tmp14_ = double_to_string (self->priv->data->visibility), " M", NULL));
				_g_free0 (_tmp15_);
				_g_free0 (_tmp14_);
			}
			if (self->priv->data->extras_length1 != 0) {
				g_print ("%s", "Extra info  :");
				{
					char** val_collection;
					int val_collection_length1;
					int val_it;
					val_collection = self->priv->data->extras;
					val_collection_length1 = self->priv->data->extras_length1;
					for (val_it = 0; val_it < self->priv->data->extras_length1; val_it = val_it + 1) {
						char* val;
						val = g_strdup (val_collection[val_it]);
						{
							char* _tmp16_;
							g_print ("%s", _tmp16_ = g_strconcat (" ", string_to_string (val), NULL));
							_g_free0 (_tmp16_);
							_g_free0 (val);
						}
					}
				}
				g_print ("\n");
			}
			break;
		}
	} else if (_tmp19_ == ((0 != _tmp19__label1) ? _tmp19__label1 : (_tmp19__label1 = g_quark_from_static_string ("raw"))))
	switch (0) {
		default:
		{
			char* _tmp17_;
			g_print ("%s", _tmp17_ = g_strconcat (string_to_string (self->priv->data->raw_code), "\n", NULL));
			_g_free0 (_tmp17_);
			break;
		}
	} else if (_tmp19_ == ((0 != _tmp19__label2) ? _tmp19__label2 : (_tmp19__label2 = g_quark_from_static_string ("format"))))
	switch (0) {
		default:
		{
			break;
		}
	}
}


static void formatter_class_init (FormatterClass * klass) {
	formatter_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FormatterPrivate));
	G_OBJECT_CLASS (klass)->finalize = formatter_finalize;
}


static void formatter_instance_init (Formatter * self) {
	self->priv = FORMATTER_GET_PRIVATE (self);
}


static void formatter_finalize (GObject* obj) {
	Formatter * self;
	self = FORMATTER (obj);
	_g_object_unref0 (self->priv->data);
	_g_object_unref0 (self->priv->config);
	G_OBJECT_CLASS (formatter_parent_class)->finalize (obj);
}


GType formatter_get_type (void) {
	static volatile gsize formatter_type_id__volatile = 0;
	if (g_once_init_enter (&formatter_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FormatterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) formatter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Formatter), 0, (GInstanceInitFunc) formatter_instance_init, NULL };
		GType formatter_type_id;
		formatter_type_id = g_type_register_static (G_TYPE_OBJECT, "Formatter", &g_define_type_info, 0);
		g_once_init_leave (&formatter_type_id__volatile, formatter_type_id);
	}
	return formatter_type_id__volatile;
}


void metar_abnormal_exit (GError* e, const char* str) {
	g_return_if_fail (str != NULL);
	fprintf (stderr, "Error: %s.\n", e->message);
	fprintf (stderr, "%s", str);
	exit (1);
}


gint metar_main (char** args, int args_length1) {
	gint result = 0;
	Config* config;
	WeatherSite* site;
	DecodedData* weather;
	Formatter* output;
	config = config_new (args, args_length1);
	site = weather_site_new (config);
	weather = decoded_data_new (site->raw_text);
	output = formatter_new (config, weather);
	formatter_output (output);
	result = 0;
	_g_object_unref0 (output);
	_g_object_unref0 (weather);
	_g_object_unref0 (site);
	_g_object_unref0 (config);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return metar_main (argv, argc);
}


Metar* metar_construct (GType object_type) {
	Metar * self;
	self = (Metar*) g_object_new (object_type, NULL);
	return self;
}


Metar* metar_new (void) {
	return metar_construct (TYPE_METAR);
}


static void metar_class_init (MetarClass * klass) {
	metar_parent_class = g_type_class_peek_parent (klass);
}


static void metar_instance_init (Metar * self) {
}


GType metar_get_type (void) {
	static volatile gsize metar_type_id__volatile = 0;
	if (g_once_init_enter (&metar_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MetarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) metar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Metar), 0, (GInstanceInitFunc) metar_instance_init, NULL };
		GType metar_type_id;
		metar_type_id = g_type_register_static (G_TYPE_OBJECT, "Metar", &g_define_type_info, 0);
		g_once_init_leave (&metar_type_id__volatile, metar_type_id);
	}
	return metar_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




